#!/usr/bin/python3 
from PyQt5.QtWidgets import QApplication, QMainWindow, QSplitter, QListWidgetItem, QFileDialog
from PyQt5.QtWidgets import QGridLayout, QListWidget, QFrame
from PyQt5.QtCore import Qt, QTimer

import xml.etree.ElementTree as ET
import pyqtgraph as pg
import sys

from lib.stringAxis import stringAxis
from lib.setDialog import setDialog
from lib.menubar import menubar

class TraceViewer(QMainWindow):
    def __init__(self):
        super().__init__()

        menubar(self)
        
        frame = QSplitter()
        self.setCentralWidget(frame)

        self.selection = QListWidget()
        self.selection.setEnabled(False)
        self.selection.itemClicked.connect(self.change)
        frame.addWidget(self.selection)

        self.rightGrid = QGridLayout()
        rightFrame = QFrame()
        rightFrame.setLayout(self.rightGrid)

        self.plot = pg.PlotWidget()
        self.legend = pg.LegendItem()
        self.legend.setParentItem(self.plot.getPlotItem())
        self.rightGrid.addWidget(self.plot)

        frame.addWidget(rightFrame)

        self.region = pg.LinearRegionItem()
        
        self.traceVariables = []
        self.plots = []
        self.legends = []

        if len(sys.argv) == 2:
            self.open(sys.argv[1])

        self.show()

    def open(self, path=None):
        if not path:
            path = QFileDialog.getOpenFileName(self)[0]
        if path:
            tree = ET.parse(path)
            root = tree.getroot()
            for i, traceVariable in enumerate(root.iter("TraceVariable")):
                times = list(map(str, traceVariable.find("Timestamps").text.split(',')))
                values = list(map(float, traceVariable.find("Values").text.split(',')))

                timedict = dict(enumerate(times))
                if i == 0:
                    self.rightGrid.removeWidget(self.plot)
                    self.timedict = timedict
                    self.plot = pg.PlotWidget(axisItems={'bottom' : stringAxis(self.timedict, orientation="bottom")})
                    self.legend = pg.LegendItem()
                    self.legend.setParentItem(self.plot.getPlotItem())
                    self.rightGrid.addWidget(self.plot)

                tVar = {}
                tVar['title'] = traceVariable.attrib['VarName']
                tVar['plot'] = pg.PlotDataItem(list(timedict), values, name = tVar['title'], pen = (i, 10))
                tVar['plots'] = pg.PlotDataItem(list(timedict), values, name = tVar['title'], pen = (i, 10))
                tVar['tnv'] = [list(timedict), values]
                self.traceVariables.append(tVar)
            
            if len(self.traceVariables) > 0:
                self.selection.setEnabled(True)
                for traceVariable in self.traceVariables:
                    item = QListWidgetItem(traceVariable['title'], self.selection)
                    item.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                    item.setCheckState(Qt.Unchecked)

                self.change(self.selection.item(0))

            else:
                self.selection.setEnabled(False)

    def change(self, item):
        if not self.splitButton.isChecked():
            if item.checkState() == Qt.Unchecked:
                self.add(item)
                item.setCheckState(Qt.Checked)
            else:
                self.remove(item)
                item.setCheckState(Qt.Unchecked)
        else:
            if item.checkState() == Qt.Unchecked:
                self.add(item, False)
                item.setCheckState(Qt.Checked)
            else:
                self.remove(item)
                item.setCheckState(Qt.Unchecked)

    def add(self, item, hide = True):
        for i, traceVariable in enumerate(self.traceVariables):
            if traceVariable['title'] == item.data(0):
                self.plot.addItem(traceVariable['plot'])
                self.legend.addItem(traceVariable['plot'], item.data(0))

                p = pg.PlotWidget(axisItems={'bottom' : stringAxis(self.timedict, orientation="bottom")})
                if hide:
                    p.hide()
                l = pg.LegendItem()
                j = p.getPlotItem()
                l.setParentItem(j)
                j.sigRangeChanged.connect(self.syncAxis)
                l.addItem(traceVariable['plots'], item.data(0))
                p.addItem(traceVariable['plots'])
                self.plots.append([p, i])
                self.legends.append(l)
                self.rightGrid.addWidget(p)

                break

    def remove(self, item):
        for i, traceVariable in enumerate(self.traceVariables):
            if traceVariable['title'] == item.data(0):
                self.plot.removeItem(traceVariable['plot'])
                self.legend.removeItem(item.data(0))

                for plot in self.plots:
                    if plot[1] == i:
                        plot[0].hide()
                        self.plots.remove(plot)

                break

    def auto(self):
        self.plot.autoRange()

    def set(self):
        r = setDialog.getInfo()
        if r:
            if not self.splitButton.isChecked():
                self.plot.setRange(xRange=r[0:2], yRange=r[2:4])
            else:
                for plot in self.plots:
                    plot[0].setRange(xRange=r[0:2], yRange=r[2:4])

    def region(self):
        if not self.regionButton.isChecked():
            self.regionButton.setChecked(False)
            self.plot.removeItem(self.region)
        else:
            self.regionButton.setChecked(True)
            xr = self.plot.viewRange()[0]
            w = xr[1] - xr[0]
            w = w / 2
            s = xr[0] + w/2
            e = xr[0] + w
            self.region.setRegion([s, e])
            self.plot.addItem(self.region)

    def update(self):
        if self.regionButton.isChecked():
            tmp = self.region.getRegion()
            tmp = "delta = " + str(tmp[1]-tmp[0])
            self.status.showMessage(tmp)
            for i in range(self.selection.count()):
                item = self.selection.item(i)
                if item.checkState() == Qt.Checked:
                    points = self.region.getRegion()
                    findex = min(range(len(self.traceVariables[i]['tnv'][0])),
                            key = lambda x :abs(self.traceVariables[i]['tnv'][0][x] - points[0]))
                    sindex = min(range(len(self.traceVariables[i]['tnv'][0])),
                            key = lambda x :abs(self.traceVariables[i]['tnv'][0][x] - points[1]))

                    display = " (" + str(self.traceVariables[i]['tnv'][1][findex])[:8] + ','
                    display += str(self.traceVariables[i]['tnv'][1][sindex])[:8] + ')'

                    item.setData(Qt.DisplayRole, self.traceVariables[i]['title'] + display)
                else:
                    item.setData(Qt.DisplayRole, self.traceVariables[i]['title'])
        else:
            self.status.showMessage(" ")
            for i in range(self.selection.count()):
                item = self.selection.item(i)
                item.setData(Qt.DisplayRole, self.traceVariables[i]['title'])

    def split(self):
        if self.splitButton.isChecked():
            self.syncButton.setEnabled(True)
            self.plot.hide()
            for plot in self.plots:
                plot[0].show()

            self.splitButton.setChecked(True)

        else:
            self.syncButton.setEnabled(False)
            for plot in self.plots:
                plot[0].hide()
            self.plot.show()

            self.splitButton.setChecked(False)

    def syncToggle(self):
        self.sync = not self.sync

    def syncAxis(self, item):
        if self.sync:
            item.blockSignals(True)
            for plot in self.plots:
                r = item.viewRange()
                if r != plot[0].viewRange():
                    plot[0].getPlotItem().blockSignals(True)
                    plot[0].setRange(xRange=r[0])
                    plot[0].getPlotItem().blockSignals(False)
            item.blockSignals(False)

app = QApplication(sys.argv)

masterView = TraceViewer()

sys.exit(app.exec_())
